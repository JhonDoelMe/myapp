import os
import subprocess
import asyncio
import logging
import hashlib
import json
from datetime import datetime, timedelta
from pathlib import Path
from collections import defaultdict
from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import (
    Message,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    FSInputFile,
    CallbackQuery
)
from aiogram.client.default import DefaultBotProperties
from dotenv import load_dotenv

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB –ª–∏–º–∏—Ç Telegram
CACHE_DIR = Path("video_cache")
CACHE_EXPIRE_DAYS = 7
MAX_CACHE_SIZE_GB = 1  # –õ–∏–º–∏—Ç —Ä–∞–∑–º–µ—Ä–∞ –∫–µ—à–∞ –≤ –≥–∏–≥–∞–±–∞–π—Ç–∞—Ö
STATS_FILE = Path("bot_stats.json")

# –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∫–µ—à–∞
CACHE_DIR.mkdir(exist_ok=True)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
bot_stats = {
    "total_requests": 0,
    "successful_downloads": 0,
    "failed_downloads": 0,
    "cache_hits": 0,
    "platform_stats": defaultdict(int),
    "user_stats": defaultdict(int),
    "last_activity": datetime.now().isoformat()
}

# –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
if STATS_FILE.exists():
    try:
        with open(STATS_FILE, "r") as f:
            loaded_stats = json.load(f)
            bot_stats.update(loaded_stats)
            bot_stats["platform_stats"] = defaultdict(int, loaded_stats.get("platform_stats", {}))
            bot_stats["user_stats"] = defaultdict(int, loaded_stats.get("user_stats", {}))
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}")

load_dotenv()

bot = Bot(
    token=os.getenv("BOT_TOKEN"),
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher()

def save_stats():
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ —Ñ–∞–π–ª"""
    try:
        stats_to_save = bot_stats.copy()
        stats_to_save["platform_stats"] = dict(bot_stats["platform_stats"])
        stats_to_save["user_stats"] = dict(bot_stats["user_stats"])
        
        with open(STATS_FILE, "w") as f:
            json.dump(stats_to_save, f, indent=2)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}")

def log_event(event: str, user_id: int = None, details: str = None):
    """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π"""
    log_msg = f"[EVENT] {event}"
    if user_id:
        log_msg += f" | User: {user_id}"
    if details:
        log_msg += f" | Details: {details[:100]}..." if len(details) > 100 else f" | Details: {details}"
    logger.info(log_msg)

def get_url_hash(url: str) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ö–µ—à –¥–ª—è URL"""
    return hashlib.md5(url.encode()).hexdigest()

def get_platform(url: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –ø–æ URL"""
    if "tiktok.com" in url:
        return "tiktok"
    elif "instagram.com" in url:
        return "instagram"
    elif "youtube.com/shorts" in url or "youtu.be" in url:
        return "youtube"
    return "other"

async def async_remove_file(path: str):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
    try:
        os.remove(path)
        logger.info(f"–£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {path}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ {path}: {str(e)}")

def clean_old_cache():
    """–û—á–∏—â–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã –∏–∑ –∫–µ—à–∞"""
    now = datetime.now()
    for file in CACHE_DIR.glob("*"):
        if (now - datetime.fromtimestamp(file.stat().st_mtime)) > timedelta(days=CACHE_EXPIRE_DAYS):
            try:
                file.unlink()
                logger.info(f"–£–¥–∞–ª–µ–Ω —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –∫–µ—à: {file.name}")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–µ—à–∞ {file.name}: {str(e)}")

def clean_cache_by_size():
    """–û—á–∏—â–∞–µ—Ç –∫–µ—à –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞"""
    try:
        files = sorted(CACHE_DIR.glob("*"), key=lambda f: f.stat().st_mtime)
        total_size = sum(f.stat().st_size for f in files)
        
        deleted_count = 0
        while total_size > MAX_CACHE_SIZE_GB * 1024**3 and files:
            oldest = files.pop(0)
            total_size -= oldest.stat().st_size
            oldest.unlink()
            deleted_count += 1
        
        if deleted_count > 0:
            logger.info(f"–û—á–∏—Å—Ç–∫–∞ –∫–µ—à–∞ –ø–æ —Ä–∞–∑–º–µ—Ä—É: —É–¥–∞–ª–µ–Ω–æ {deleted_count} —Ñ–∞–π–ª–æ–≤, –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–æ {total_size/1024**3:.2f}GB")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫–µ—à–∞ –ø–æ —Ä–∞–∑–º–µ—Ä—É: {str(e)}")

@dp.message(Command("start"))
async def start(message: Message):
    bot_stats["user_stats"][str(message.from_user.id)] += 1
    save_stats()
    
    log_event("Command received", message.from_user.id, "/start")
    await message.answer(
        "–ü—Ä–∏–≤—ñ—Ç! –ù–∞–¥—ñ—à–ª–∏ –º–µ–Ω—ñ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –≤—ñ–¥–µ–æ –∑ Instagram Reels, TikTok –∞–±–æ YouTube Shorts, "
        "—ñ —è –∑–∞–≤–∞–Ω—Ç–∞–∂—É –π–æ–≥–æ –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫—É! üöÄ\n\n"
        "–ü—Ä–∞—Ü—é—é –∑ —Ñ–æ—Ä–º–∞—Ç–∞–º–∏:\n"
        "‚Ä¢ TikTok: vm.tiktok.com, www.tiktok.com\n"
        "‚Ä¢ Instagram: www.instagram.com/reel\n"
        "‚Ä¢ YouTube: youtu.be, youtube.com/shorts\n\n"
        "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞:\n"
        f"‚Ä¢ –û–±—Ä–æ–±–ª–µ–Ω–æ –∑–∞–ø–∏—Ç—ñ–≤: {bot_stats['total_requests']}\n"
        f"‚Ä¢ –í–¥–∞–ª–∏—Ö –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—å: {bot_stats['successful_downloads']}\n"
        f"‚Ä¢ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ –∫–µ—à—É: {bot_stats['cache_hits']}")

@dp.message(Command("stats"))
async def show_stats(message: Message):
    stats_msg = (
        "üìä –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        f"‚Ä¢ –í—Å—å–æ–≥–æ –∑–∞–ø–∏—Ç—ñ–≤: {bot_stats['total_requests']}\n"
        f"‚Ä¢ –í–¥–∞–ª–∏—Ö –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—å: {bot_stats['successful_downloads']}\n"
        f"‚Ä¢ –ù–µ–≤–¥–∞–ª–∏—Ö —Å–ø—Ä–æ–±: {bot_stats['failed_downloads']}\n"
        f"‚Ä¢ –ó–≤–µ—Ä–Ω–µ–Ω—å –¥–æ –∫–µ—à—É: {bot_stats['cache_hits']}\n"
        "üìà –ó–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º–∏:\n"
    )
    
    for platform, count in sorted(bot_stats["platform_stats"].items()):
        platform_name = {
            "tiktok": "TikTok",
            "instagram": "Instagram", 
            "youtube": "YouTube",
            "other": "–Ü–Ω—à—ñ"
        }.get(platform, platform.capitalize())
        
        stats_msg += f"‚Ä¢ {platform_name}: {count}\n"
    
    await message.answer(stats_msg)

@dp.message(F.text | F.caption)
async def handle_links(message: Message):
    text = message.text or message.caption
    url = extract_url(text)
    user_id = message.from_user.id
    
    if not url:
        log_event("No URL found", user_id)
        await message.answer("üî¥ –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è. –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑!")
        return

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    bot_stats["total_requests"] += 1
    bot_stats["user_stats"][str(user_id)] += 1
    platform = get_platform(url)
    bot_stats["platform_stats"][platform] += 1
    save_stats()
    
    log_event("Message received", user_id, f"Text: {text[:50]}...")

    wait_msg = None
    file_path = None
    
    try:
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ—à–∞
        url_hash = get_url_hash(url)
        cached_file = CACHE_DIR / f"{url_hash}.mp4"
        
        if cached_file.exists():
            bot_stats["cache_hits"] += 1
            save_stats()
            log_event("Cache hit", user_id, f"URL: {url}")
            file_path = str(cached_file)
        else:
            log_event("Video processing started", user_id, f"URL: {url}")
            wait_msg = await message.answer("‚è≥ –û–±—Ä–æ–±–ª—è—é –≤–∞—à–µ –≤—ñ–¥–µ–æ...")
            
            start_time = datetime.now()
            file_path = await download_video(url, url_hash)
            download_time = (datetime.now() - start_time).total_seconds()
            
            log_event("Video downloaded", user_id, 
                     f"Path: {file_path}, Size: {os.path.getsize(file_path)/1024/1024:.2f}MB, "
                     f"Time: {download_time:.2f}s")

        file_size = os.path.getsize(file_path)
        if file_size > MAX_FILE_SIZE:
            raise ValueError(f"–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({file_size/1024/1024:.2f}MB)")

        video = FSInputFile(file_path)
        await message.answer_video(
            video,
            caption="–û—Å—å –≤–∞—à–µ –≤—ñ–¥–µ–æ –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫—É! ‚úÖ",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üì• –°–∫–∞—á–∞—Ç–∏ —â–µ", callback_data="download_more")]
            ])
        )

        bot_stats["successful_downloads"] += 1
        save_stats()
        log_event("Video sent successfully", user_id)

    except subprocess.TimeoutExpired as e:
        bot_stats["failed_downloads"] += 1
        save_stats()
        logger.error(f"Timeout error for user {user_id}: {str(e)}")
        await message.answer("üî¥ –ß–∞—Å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤–∏–π—à–æ–≤. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
    except subprocess.CalledProcessError as e:
        bot_stats["failed_downloads"] += 1
        save_stats()
        logger.error(f"Download failed for user {user_id}. URL: {url}. Error: {str(e)}")
        await message.answer("üî¥ –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤—ñ–¥–µ–æ. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è.")
    except Exception as e:
        bot_stats["failed_downloads"] += 1
        save_stats()
        logger.error(f"Unexpected error for user {user_id}: {str(e)}", exc_info=True)
        await message.answer("üî¥ –°—Ç–∞–ª–∞—Å—è –Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–∞ –ø–æ–º–∏–ª–∫–∞. –°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è.")
    finally:
        if wait_msg:
            try:
                await bot.delete_message(chat_id=message.chat.id, message_id=wait_msg.message_id)
            except Exception as e:
                logger.warning(f"Failed to delete wait message: {str(e)}")
        if file_path and not file_path.startswith(str(CACHE_DIR)):
            await async_remove_file(file_path)

def extract_url(text: str) -> str | None:
    import re
    url_pattern = (
        r'https?://(?:vm\.tiktok\.com|'
        r'www\.tiktok\.com|'
        r'www\.instagram\.com/reel|'
        r'youtu\.be|'
        r'youtube\.com/shorts)\S+'
    )
    match = re.search(url_pattern, text)
    return match.group(0) if match else None

async def download_video(url: str, url_hash: str) -> str:
    """–°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤ –∫–µ—à"""
    clean_cache_by_size()  # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –ø–µ—Ä–µ–¥ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ–º
    
    output_path = str(CACHE_DIR / f"{url_hash}.mp4")
    command = [
        "yt-dlp",
        "-f", "best[ext=mp4]",
        "-o", output_path,
        "--no-warnings",
        "--quiet",
        url
    ]
    
    logger.debug(f"Download command: {' '.join(command)}")
    result = subprocess.run(command, check=True, timeout=120, capture_output=True, text=True)
    
    if result.stderr:
        logger.debug(f"yt-dlp stderr: {result.stderr}")
    if result.stdout:
        logger.debug(f"yt-dlp stdout: {result.stdout}")
    
    return output_path

@dp.callback_query(F.data == "download_more")
async def download_more(callback: CallbackQuery):
    log_event("Button pressed", callback.from_user.id, "download_more")
    await callback.answer()
    await callback.message.answer("–ù–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–æ–≤–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –≤—ñ–¥–µ–æ:")

async def on_startup():
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞"""
    logger.info("Cleaning old cache...")
    clean_old_cache()  # –°–Ω–∞—á–∞–ª–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
    clean_cache_by_size()  # –ó–∞—Ç–µ–º –ø–æ —Ä–∞–∑–º–µ—Ä—É
    logger.info("Bot starting...")

async def main():
    await on_startup()
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        logger.critical(f"Bot crashed: {str(e)}", exc_info=True)
        raise